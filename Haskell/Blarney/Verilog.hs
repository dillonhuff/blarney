{-|
Module      : Blarney.Verilog
Description : Verilog generation
Copyright   : (c) Matthew Naylor, 2019
License     : MIT
Maintainer  : mattfn@gmail.com
Stability   : experimental

Convert Blarney functions to Verilog modules.
-}

module Blarney.Verilog
  ( writeVerilogModule  -- Generate Verilog module
  , writeVerilogTop     -- Generate Verilog top-level module
  ) where

-- Standard imports
import Prelude
import Data.List
import Numeric (showHex)
import System.IO
import Data.Maybe
import System.Process
import Data.Text.Prettyprint.Doc
import Data.Text.Prettyprint.Doc.Render.Text

-- Blarney imports
import Blarney.BV
import Blarney.Module
import Blarney.Interface
import Blarney.IfThenElse

-- Toplevel API
--------------------------------------------------------------------------------

-- |Convert given Blarney function to a Verilog module
writeVerilogModule :: Modular a
                   => a          -- ^ Blarney function
                   -> String     -- ^ Module name
                   -> String     -- ^ Output directory
                   -> IO ()
writeVerilogModule top mod dir =
    do system ("mkdir -p " ++ dir)
       nl <- netlist (makeModule top)
       writeVerilog fileName mod nl
  where
    fileName = dir ++ "/" ++ mod ++ ".v"

-- |Convert given Blarney function to a top-level Verilog module
writeVerilogTop :: Module ()  -- ^ Blarney module
                -> String     -- ^ Top-level module name
                -> String     -- ^ Output directory
                -> IO ()
writeVerilogTop top mod dir =
    do nl <- netlist top
       system ("mkdir -p " ++ dir)
       writeVerilog (dir ++ "/" ++ mod ++ ".v") mod nl
       writeFile (dir ++ "/" ++ mod ++ ".cpp") simCode
       writeFile (dir ++ "/" ++ mod ++ ".mk") makefileIncCode
       writeFile (dir ++ "/Makefile") makefileCode
  where
    fileName = dir ++ "/" ++ mod ++ ".v"

    simCode =
      unlines [
        "// Generated by Blarney"
      , "#include <verilated.h>"
      , "#include \"V" ++ mod ++ ".h\""
      , "V" ++ mod ++ " *top;"
      , "vluint64_t main_time = 0;"
      , "// Called by $time in Verilog"
      , "double sc_time_stamp () {"
      , "  return main_time;"
      , "}"
      , "int main(int argc, char** argv) {"
      , "  Verilated::commandArgs(argc, argv);"
      , "  top = new V" ++ mod ++ ";"
      , "  while (!Verilated::gotFinish()) {"
      , "    top->clock = 0; top->eval();"
      , "    top->clock = 1; top->eval();"
      , "    main_time++;"
      , "  }"
      , "  top->final(); delete top; return 0;"
      , "}"
      ]

    makefileIncCode =
      unlines [
        "all: " ++ mod
      , mod ++ ": *.v *.cpp"
      , "\tverilator -cc " ++ mod ++ ".v " ++ "-exe "
                           ++ mod ++ ".cpp " ++ "-o " ++ mod
                           ++ " -Wno-UNSIGNED "
                           ++ " -y $(BLARNEY_ROOT)/Verilog "
      , "\tmake -C obj_dir -j -f V" ++ mod ++ ".mk " ++ mod
      , "\tcp obj_dir/" ++ mod ++ " ."
      , "\trm -rf obj_dir"
      , ".PHONY: clean clean-" ++ mod
      , "clean: clean-" ++ mod
      , "clean-" ++ mod ++ ":"
      , "\trm -f " ++ mod
      ]

    makefileCode = "include *.mk"

writeVerilog :: String -> String -> [Net] -> IO ()
writeVerilog fileName modName netlist = do
  h <- openFile fileName WriteMode
  --hPutDoc h (emitVerilogModule modName netlist)
  --renderIO h $ layoutPretty defaultLayoutOptions (emitVerilogModule modName netlist)
  renderIO h $ layoutSmart defaultLayoutOptions (emitVerilogModule modName netlist)
  hClose h

-- Internal helpers
--------------------------------------------------------------------------------

-- NetVerilog helper type
data NetVerilog = NetVerilog { decl :: Maybe (Doc ()) -- declaration
                             , inst :: Maybe (Doc ()) -- instanciation
                             , alws :: Maybe (Doc ()) -- always block
                             }
-- general helpers
--------------------------------------------------------------------------------
(<^>) a b = vsep [a,b]
p = pretty
argStyle = align . sep . (punctuate comma)
remainCols f = pageWidth (\w@(AvailablePerLine l r) -> column (\c -> f (l-c)))
emitName :: (Int, Int) -> Doc ()
emitName (id, nOut) = p "v" <> p (show id) <> p "_" <> p (show nOut)
emitNameWidth :: Int -> (Int, Int) -> Doc ()
emitNameWidth width wire = brackets (p (show $ width-1) <> colon <> p "0") <+> emitName wire
emitVerilogModule :: String -> [Net] -> Doc ()
emitVerilogModule modName netlst =
     p "module" <+> p modName <+> parens emitIOs <> semi
  <^> indent 2 ( emitComment "Declarations"
             <^> emitCommentLine
             <^> vsep (catMaybes $ map decl netVs)
             <^> emitComment "Instances"
             <^> emitCommentLine
             <^> vsep (catMaybes $ map inst netVs)
             <^> emitComment "Always block"
             <^> emitCommentLine
             <^> p "always" <+> p "@" <> parens (p "posedge clock") <+> p "begin"
             <^> indent 2 ( vsep (catMaybes $ map alws netVs))
             <^> p "end")
  <^> p "endmodule"
  where netVs = map genNetVerilog netlst
        netPrims = map netPrim netlst
        ins = [Input w s | (w, s) <- nub [(w, s) | Input w s <- netPrims]]
        outs = [Output w s | Output w s <- netPrims]
        emitIOs = argStyle $ (p "input wire clock") : (map emitIO (ins ++ outs))
        emitIO (Input w s) = p "input wire" <+> brackets (p (show $ w-1) <> colon <> p "0") <+> p s
        emitIO (Output w s) = p "output wire" <+> brackets (p (show $ w-1) <> colon <> p "0") <+> p s
        emitIO _ = emptyDoc
        emitComment cmt = p "//" <+> p cmt
        emitCommentLine = remainCols (\r -> p "//" <> p (replicate (r-2) '/'))

-- declaration helpers
--------------------------------------------------------------------------------
declName width name =
  emitNameWidth width name <> semi
declNameInitHex width wire init =
  emitNameWidth width wire <+> equals <+> p (show width) <> p "'h" <> p (showHex init "") <> semi
declWireInitBits width wire b =
  p "wire" <+> emitNameWidth width wire <+> equals <+> p (show width) <> p "'b" <> p bitStr <> semi
  where bitStr = replicate width $ chr b
        chr One = '1'
        chr Zero = '0'
        chr DontCare = 'x'
declWire width wire = p "wire" <+> declName width wire
declWireInit width wire init = p "wire" <+> declNameInitHex width wire init
declReg width reg = p "reg" <+> declName width reg
declRegInit width reg init = p "reg" <+> declNameInitHex width reg init
declRAM initFile numPorts _ dw id =
  vsep $ map (\n -> declWire dw (id, n)) [0..numPorts-1]
declRegFile initFile aw dw id =
      p "reg" <+> brackets ((p $ show (dw-1)) <> colon <> p "0")
  <+> p "rf" <> (p $ show id) <+> brackets (parens (p "2**" <> (p $ show aw)) <> p "-1" <> colon <> p "0") <> semi
  <> emitInit
  where emitInit = case initFile of
          ""    ->     emptyDoc
          fname ->     hardline <> p "generate initial $readmemh" <> parens
                       (p fname <> comma <+> p "rf" <> (p $ show id)) <> semi
                   <+> p "endgenerate"

-- instanciation helpers
--------------------------------------------------------------------------------
instPrefixOp op net =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> p op <> parens (emitName (netInputs net !! 0)) <> semi
instInfixOp op net =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> emitName (netInputs net !! 0)
  <+> p op <+> emitName (netInputs net !! 1) <> semi
instShift w op net =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> a0 <+> p op <+> emitName (netInputs net !! 1) <> semi
  where a0 = if op == ">>>" then p "$signed" <> parens a0name
                            else a0name
        a0name = emitName (netInputs net !! 0)
instReplicate w net =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> braces ((p $ show w) <> braces (emitName (netInputs net !! 0))) <> semi
instMux net =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> emitName (netInputs net !! 0) <+> p "?"
  <+> emitName (netInputs net !! 1) <+> colon
  <+> emitName (netInputs net !! 2) <> semi
instConcat net =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> braces ( emitName (netInputs net !! 0) <> comma <+>
               emitName (netInputs net !! 1)) <> semi
instSelectBits net hi lo =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> emitName (netInputs net !! 0) <> brackets
      ((p $ show hi) <> colon <> (p $ show lo)) <> semi
instZeroExtend net wi wo =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> braces (braces ((p $ show (wo-wi)) <> braces (p "1'b0"))
  <>  comma <+> emitName (netInputs net !! 0)) <> semi
instSignExtend net wi wo =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> braces (braces ((p $ show (wo-wi)) <> braces (emitName (netInputs net !! 0)
  <>  brackets (p $ show (wi-1)))) <> comma
  <+> emitName (netInputs net !! 0)) <> semi
instCustom net name ins outs params =
      p name <> emitParams <> p name <> p "_" <> p (show $ netInstId net) <+> emitArgs
  <>  semi
  where numParams = length params
        emitParams = if numParams == 0 then space
                     else p "#" <> parens (argStyle allParams) <> space
        allParams = [ dot <> p key <> parens (p val) | (key :-> val, i) <- zip params [1..] ]
        args = zip ins (netInputs net) ++ [ (o, (netInstId net, n))
                                          | (o, n) <- zip (map fst outs) [0..] ]
        numArgs = length args
        emitArgs =   parens (argStyle $ (p ".clock(clock)"):allArgs)
        allArgs = [ dot <> p name <> parens (emitName wire)
                  | ((name, wire), i) <- zip args [1..] ]
instTestPlusArgs net s =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> p "$test$plusargs" <> parens (dquotes $ p s) <+> p "== 0 ? 0 : 1;"
instOutput net s =
      p "assign" <+> p s <+> equals <+>  emitName (netInputs net !! 0) <> semi
instInput net s =
    p "assign" <+> emitName (netInstId net, 0) <+> equals <+> p s <> semi
instRAM net i aw dw =
      p "BlockRAM#" <> parens (argStyle
                        [ p ".INIT_FILE"  <> parens (p (show $ fromMaybe "UNUSED" i))
                        , p ".ADDR_WIDTH" <> parens (p $ show aw)
                        , p ".DATA_WIDTH" <> parens (p $ show dw) ])
  <+> p "ram" <> p (show $ netInstId net) <> parens (argStyle
                        [ p ".CLK(clock)"
                        , p ".DI"   <> parens (emitName (netInputs net !! 1))
                        , p ".ADDR" <> parens (emitName (netInputs net !! 0))
                        , p ".WE"   <> parens (emitName (netInputs net !! 2))
                        , p ".DO"   <> parens (emitName (netInstId net, 0)) ])
  <>  semi
instTrueDualRAM net i aw dw =
      p "BlockRAMTrueDual#" <> parens (argStyle
                        [ p ".INIT_FILE"  <> parens (p (show $ fromMaybe "UNUSED" i))
                        , p ".ADDR_WIDTH" <> parens (p $ show aw)
                        , p ".DATA_WIDTH" <> parens (p $ show dw) ])
  <+> p "ram" <> p (show $ netInstId net) <> parens (argStyle
                        [ p ".CLK(clock)"
                        , p ".DI_A"   <> parens (emitName (netInputs net !! 1))
                        , p ".ADDR_A" <> parens (emitName (netInputs net !! 0))
                        , p ".WE_A"   <> parens (emitName (netInputs net !! 2))
                        , p ".DO_A"   <> parens (emitName (netInstId net, 0))
                        , p ".DI_B"   <> parens (emitName (netInputs net !! 4))
                        , p ".ADDR_B" <> parens (emitName (netInputs net !! 3))
                        , p ".WE_B"   <> parens (emitName (netInputs net !! 5))
                        , p ".DO_B"   <> parens (emitName (netInstId net, 1)) ])
  <>  semi
instRegFileRead id net =
      p "assign" <+> emitName (netInstId net, 0) <+> equals
  <+> p "rf" <> (p $ show id) <> brackets (emitName (netInputs net !! 0)) <> semi

-- always block helpers
--------------------------------------------------------------------------------
alwsRegister net = emitName (netInstId net, 0) <+> p "<="
               <+> emitName (netInputs net !! 0) <> semi
alwsRegisterEn net =
      p "if" <+> parens (emitName (netInputs net !! 0) <+> p "== 1")
  <+> emitName (netInstId net, 0) <+> p "<=" <+> emitName (netInputs net !! 1)
  <>  semi
alwsDisplay args net =
      p "if" <+> parens (emitName (netInputs net !! 0) <+> p "== 1") <+> p "$write"
  <>  parens (argStyle $ fmtArgs args (tail (netInputs net)))
  <>  semi
  where fmtArgs [] _ = []
        fmtArgs (DisplayArgString s : args) wires = (p $ show s) : (fmtArgs args wires)
        fmtArgs (DisplayArgBit w : args) (wire:wires) = (emitName wire) : (fmtArgs args wires)
alwsFinish net =
  p "if" <+> parens (emitName (netInputs net !! 0) <+> p "== 1") <+> p "$finish" <> semi
alwsRegFileWrite id net =
      p "if" <+> parens (emitName (netInputs net !! 0) <+> p "== 1")
  <+> p "rf" <> p (show id) <> brackets (emitName (netInputs net !! 1)) <+> p "<="
  <+> emitName (netInputs net !! 2) <> semi

-- generate NetVerilog
--------------------------------------------------------------------------------
genNetVerilog net = case netPrim net of
  Const w i             -> dfltNV { decl = Just $ declWireInit w nId i }
  ConstBits w b         -> dfltNV { decl = Just $ declWireInitBits w nId b }
  Add w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "+" net }
  Sub w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "-" net }
  Mul w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "*" net }
  Div w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "/" net }
  Mod w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "%" net }
  Not w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instPrefixOp "~" net }
  And w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "&" net }
  Or w                  -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "|" net }
  Xor w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInfixOp "^" net }
  ShiftLeft w           -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instShift w "<<" net }
  ShiftRight w          -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instShift w ">>" net }
  ArithShiftRight w     -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instShift w ">>>" net }
  Equal w               -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instInfixOp "==" net }
  NotEqual w            -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instInfixOp "!=" net }
  LessThan w            -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instInfixOp "<" net }
  LessThanEq w          -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instInfixOp "<=" net }
  Register i w          -> dfltNV { decl = Just $ declRegInit w nId i
                                  , alws = Just $ alwsRegister net }
  RegisterEn i w        -> dfltNV { decl = Just $ declRegInit w nId i
                                  , alws = Just $ alwsRegisterEn net }
  BRAM i aw dw          -> dfltNV { decl = Just $ declRAM i 1 aw dw (netInstId net)
                                  , inst = Just $ instRAM net i aw dw }
  TrueDualBRAM i aw dw  -> dfltNV { decl = Just $ declRAM i 2 aw dw (netInstId net)
                                  , inst = Just $ instTrueDualRAM net i aw dw }
  ReplicateBit w        -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instReplicate w net }
  ZeroExtend wi wo      -> dfltNV { decl = Just $ declWire wo nId
                                  , inst = Just $ instZeroExtend net wi wo }
  SignExtend wi wo      -> dfltNV { decl = Just $ declWire wo nId
                                  , inst = Just $ instSignExtend net wi wo }
  SelectBits w hi lo    -> dfltNV { decl = Just $ declWire (1+hi-lo) nId
                                  , inst = Just $ instSelectBits net hi lo }
  Concat aw bw          -> dfltNV { decl = Just $ declWire (aw+bw) nId
                                  , inst = Just $ instConcat net }
  Mux w                 -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instMux net }
  CountOnes w           -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instPrefixOp "$countones" net }
  Identity w            -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instPrefixOp "" net }
  Display args          -> dfltNV { alws = Just $ alwsDisplay args net }
  Finish                -> dfltNV { alws = Just $ alwsFinish net }
  TestPlusArgs s        -> dfltNV { decl = Just $ declWire 1 nId
                                  , inst = Just $ instTestPlusArgs net s }
  Input w s             -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instInput net s }
  Output w s            -> dfltNV { inst = Just $ instOutput net s }
  RegFileMake f aw dw i -> dfltNV { decl = Just $ declRegFile f aw dw i }
  RegFileRead w id      -> dfltNV { decl = Just $ declWire w nId
                                  , inst = Just $ instRegFileRead id net }
  RegFileWrite _ _ id   -> dfltNV { alws = Just $ alwsRegFileWrite id net }
  Custom p is os ps     -> dfltNV {
                              decl = Just $ sep [ declWire w (netInstId net, n)
                                                | ((o, w), n) <- zip os [0..] ]
                            , inst = Just $ instCustom net p is os ps }
  where nId = (netInstId net, 0)
        dfltNV = NetVerilog { decl = Nothing
                            , inst = Nothing
                            , alws = Nothing }
